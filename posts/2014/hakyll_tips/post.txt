lhs文書のテストも兼ねて、ここを作るときに使ったあれこれを書き出しておきます。随時更新。
lhsで書いているのでヘッダーのsourceリンクからダウンロードしてそのまま実行する事が可能です。
もくじ

ハイライトのcssどうするの
元々minifyされているcssはライセンス書いてるしcomplessしたくない
タグごとのページもpaginateしたい
表にはtableクラスを付けないとbootstrapが！


&gt; {-#LANGUAGE OverloadedStrings #-}
&gt; import           Hakyll
&gt; import qualified Text.Highlighting.Kate as Kate
&gt; import qualified Text.HTML.TagSoup      as TS
&gt; import           Data.List(partition)
&gt; 
&gt; main :: IO ()
&gt; main = hakyll $ highlightCss &gt;&gt; cssRules &gt;&gt; posts
ハイライトのcssどうするの
pandocCompilerで文書をコンパイルすると、コードにはハイライト用のマークアップを付けてくれますが、cssは自分で用意する必要があります。 このハイライト機能はhighlighting-kateにより提供されているものなので、その中に定義されているスタイルを使って、以下の様なルールを書いておけば良いと思います。
&gt; highlightCss :: Rules ()
&gt; highlightCss = create [&quot;css/highlight.css&quot;] $ do
&gt;     route idRoute
&gt;     compile $ makeItem (Kate.styleToCss Kate.kate)
元々minifyされているcssはライセンス書いてるしcomplessしたくない
Patterns用の論理演算を使いましょう。



Bool
Patterns




&amp;&amp;
.&amp;&amp;.


||
.||.


not
complement



&gt; cssRules :: Rules ()
&gt; cssRules = do
&gt;     match &quot;css/*.min.css&quot; $ do
&gt;         route idRoute
&gt;         compile copyFileCompiler
&gt;     match (&quot;css/*&quot; .&amp;&amp;. complement &quot;css/*.min.css&quot;) $ do
&gt;         route idRoute
&gt;         compile compressCssCompiler
タグごとのページもpaginateしたい
普通にネストできます。すごい。 長いのでソースコード参照
表にはtableクラスを付けないとbootstrapが！
withTagsを使いましょう。
&gt; addClass :: String -&gt; TS.Tag String -&gt; TS.Tag String
&gt; addClass cls (TS.TagOpen name attr) = case partition ((== &quot;class&quot;) . fst) attr of
&gt;     ([],         _)     -&gt; TS.TagOpen name $ (&quot;class&quot;, cls) : attr
&gt;     ((_,cls&#39;):_, attr&#39;) -&gt; TS.TagOpen name $ (&quot;class&quot;, cls ++ &#39; &#39;: cls&#39;) : attr&#39;
&gt; addClass _ tag = tag
&gt; 
&gt; postCompiler :: Compiler (Item String)
&gt; postCompiler = fmap (withTags process) `fmap` pandocCompiler
&gt;   where process tag | TS.isTagOpenName &quot;table&quot; tag = addClass &quot;table&quot; tag
&gt;                     | otherwise                    = tag
&gt; 
&gt; posts :: Rules ()
&gt; posts = match &quot;posts/**.md&quot; $ do
&gt;     route $ setExtension &quot;html&quot;
&gt;     compile postCompiler