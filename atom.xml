<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>About:Blank</title>
    <link href="http://philopon.github.io/atom.xml" rel="self" />
    <link href="http://philopon.github.io" />
    <id>http://philopon.github.io/atom.xml</id>
    <author>
        <name>philopon</name>
        <email></email>
    </author>
    <updated>2014-03-02T13:39:08Z</updated>
    <entry>
    <title>zshでcabal-sandboxの状態を表示する</title>
    <link href="http://philopon.github.io/posts/2014/cabal-sandbox-zsh.html" />
    <id>http://philopon.github.io/posts/2014/cabal-sandbox-zsh.html</id>
    <published>2014-03-02T13:39:08Z</published>
    <updated>2014-03-02T13:39:08Z</updated>
    <summary type="html"><![CDATA[<p>表題の通りです。 sandbox中のパッケージ数を表示させてます。</p>
<div class="figure">
<img src="ss.png" alt="cabal-sandboxのパッケージ数を表示" /><p class="caption">cabal-sandboxのパッケージ数を表示</p>
</div>
<p>ついでにsandbox中でsandbox外のパッケージを使用したい事はまずないので、(やや過激ですが)<code>ghc-pkg</code>,<code>runhaskell</code>,<code>runghc</code>,<code>ghc</code>,<code>ghci</code>をsandbox中で実行した時はsandbox内のパッケージを使用する様にしてみました。便利。</p>
<!-- more -->

<dl>
<dt><a href="https://github.com/philopon/.zsh.d/blob/e7eb4e5540e41655814406087c226905e72c4aa8/haskell.zsh">haskell.zsh</a></dt>
<dd>関数定義、ghcコマンド群のエイリアス設定
</dd>
<dt><a href="https://github.com/philopon/.zsh.d/blob/e7eb4e5540e41655814406087c226905e72c4aa8/haskell.zsh#L17-L32">prompt.zsh</a></dt>
<dd>プロンプトの設定
</dd>
</dl>]]></summary>
</entry>
<entry>
    <title>Hakyll tips</title>
    <link href="http://philopon.github.io/posts/2014/hakyll_tips.html" />
    <id>http://philopon.github.io/posts/2014/hakyll_tips.html</id>
    <published>2014-02-26T16:10:05Z</published>
    <updated>2014-02-26T16:10:05Z</updated>
    <summary type="html"><![CDATA[<p>lhs文書のテストも兼ねて、ここを作るときに使ったあれこれを書き出しておきます。随時更新。</p>
<p>lhsで書いているのでヘッダーの<code>source</code>リンクからダウンロードしてそのまま実行する事が可能です。</p>
<h1 id="もくじ">もくじ</h1>
<ul>
<li><a href="#ハイライトのcssどうするの">ハイライトのcssどうするの</a></li>
<li><a href="#元々minifyされているcssはライセンス書いてるしcomplessしたくない">元々minifyされているcssはライセンス書いてるしcomplessしたくない</a></li>
<li><a href="#タグごとのページもpaginateしたい">タグごとのページもpaginateしたい</a></li>
<li><a href="#表にはtableクラスを付けないとbootstrapが">表にはtableクラスを付けないとbootstrapが！</a></li>
</ul>
<p><!-- more --></p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-#LANGUAGE OverloadedStrings #-}</span>
<span class="ot">&gt;</span> <span class="kw">import           </span><span class="dt">Hakyll</span>
<span class="ot">&gt;</span> <span class="kw">import qualified</span> <span class="dt">Text.Highlighting.Kate</span> <span class="kw">as</span> <span class="dt">Kate</span>
<span class="ot">&gt;</span> <span class="kw">import qualified</span> <span class="dt">Text.HTML.TagSoup</span>      <span class="kw">as</span> <span class="dt">TS</span>
<span class="ot">&gt;</span> <span class="kw">import           </span><span class="dt">Data.List</span>(partition)
<span class="ot">&gt;</span> 
<span class="ot">&gt; main ::</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> main <span class="fu">=</span> hakyll <span class="fu">$</span> highlightCss <span class="fu">&gt;&gt;</span> cssRules <span class="fu">&gt;&gt;</span> posts</code></pre>
<h1 id="ハイライトのcssどうするの">ハイライトのcssどうするの</h1>
<p><code>pandocCompiler</code>で文書をコンパイルすると、コードにはハイライト用のマークアップを付けてくれますが、cssは自分で用意する必要があります。 このハイライト機能は<a href="http://hackage.haskell.org/package/highlighting-kate"><code>highlighting-kate</code></a>により提供されているものなので、その中に定義されている<a href="http://hackage.haskell.org/package/highlighting-kate-0.5.6.1/docs/Text-Highlighting-Kate-Styles.html">スタイル</a>を使って、以下の様なルールを書いておけば良いと思います。</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; highlightCss ::</span> <span class="dt">Rules</span> ()
<span class="ot">&gt;</span> highlightCss <span class="fu">=</span> create [<span class="st">&quot;css/highlight.css&quot;</span>] <span class="fu">$</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     route idRoute
<span class="ot">&gt;</span>     compile <span class="fu">$</span> makeItem (Kate.styleToCss Kate.kate)</code></pre>
<h1 id="元々minifyされているcssはライセンス書いてるしcomplessしたくない">元々minifyされているcssはライセンス書いてるしcomplessしたくない</h1>
<p><code>Patterns</code>用の論理演算を使いましょう。</p>
<table class="table">
<thead>
<tr class="header">
<th align="left">Bool</th>
<th align="left">Patterns</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">&amp;&amp;</td>
<td align="left">.&amp;&amp;.</td>
</tr>
<tr class="even">
<td align="left">||</td>
<td align="left">.||.</td>
</tr>
<tr class="odd">
<td align="left">not</td>
<td align="left">complement</td>
</tr>
</tbody>
</table>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; cssRules ::</span> <span class="dt">Rules</span> ()
<span class="ot">&gt;</span> cssRules <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     match <span class="st">&quot;css/*.min.css&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
<span class="ot">&gt;</span>         route idRoute
<span class="ot">&gt;</span>         compile copyFileCompiler
<span class="ot">&gt;</span>     match (<span class="st">&quot;css/*&quot;</span> <span class="fu">.&amp;&amp;.</span> complement <span class="st">&quot;css/*.min.css&quot;</span>) <span class="fu">$</span> <span class="kw">do</span>
<span class="ot">&gt;</span>         route idRoute
<span class="ot">&gt;</span>         compile compressCssCompiler</code></pre>
<h1 id="タグごとのページもpaginateしたい">タグごとのページもpaginateしたい</h1>
<p>普通にネストできます。すごい。 長いので<a href="https://github.com/philopon/philopon.github.io/blob/b87a2b45c165cd40ceb526ea8347ba828774cc1c/site.hs#L123-L143">ソースコード</a>参照</p>
<h1 id="表にはtableクラスを付けないとbootstrapが">表にはtableクラスを付けないとbootstrapが！</h1>
<p>withTagsを使いましょう。</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; addClass ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">TS.Tag</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">TS.Tag</span> <span class="dt">String</span>
<span class="ot">&gt;</span> addClass cls (<span class="dt">TS.TagOpen</span> name attr) <span class="fu">=</span> <span class="kw">case</span> partition ((<span class="fu">==</span> <span class="st">&quot;class&quot;</span>) <span class="fu">.</span> fst) attr <span class="kw">of</span>
<span class="ot">&gt;</span>     ([],         _)     <span class="ot">-&gt;</span> <span class="dt">TS.TagOpen</span> name <span class="fu">$</span> (<span class="st">&quot;class&quot;</span>, cls) <span class="fu">:</span> attr
<span class="ot">&gt;</span>     ((_,cls')<span class="fu">:</span>_, attr') <span class="ot">-&gt;</span> <span class="dt">TS.TagOpen</span> name <span class="fu">$</span> (<span class="st">&quot;class&quot;</span>, cls <span class="fu">++</span> <span class="ch">' '</span><span class="fu">:</span> cls') <span class="fu">:</span> attr'
<span class="ot">&gt;</span> addClass _ tag <span class="fu">=</span> tag
<span class="ot">&gt;</span> 
<span class="ot">&gt; postCompiler ::</span> <span class="dt">Compiler</span> (<span class="dt">Item</span> <span class="dt">String</span>)
<span class="ot">&gt;</span> postCompiler <span class="fu">=</span> fmap (withTags process) <span class="ot">`fmap`</span> pandocCompiler
<span class="ot">&gt;</span>   <span class="kw">where</span> process tag <span class="fu">|</span> TS.isTagOpenName <span class="st">&quot;table&quot;</span> tag <span class="fu">=</span> addClass <span class="st">&quot;table&quot;</span> tag
<span class="ot">&gt;</span>                     <span class="fu">|</span> otherwise                    <span class="fu">=</span> tag
<span class="ot">&gt;</span> 
<span class="ot">&gt; posts ::</span> <span class="dt">Rules</span> ()
<span class="ot">&gt;</span> posts <span class="fu">=</span> match <span class="st">&quot;posts/**.md&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     route <span class="fu">$</span> setExtension <span class="st">&quot;html&quot;</span>
<span class="ot">&gt;</span>     compile postCompiler</code></pre>]]></summary>
</entry>
<entry>
    <title>runsandbox作った</title>
    <link href="http://philopon.github.io/posts/2014/runsandbox.html" />
    <id>http://philopon.github.io/posts/2014/runsandbox.html</id>
    <published>2014-02-26T00:53:15Z</published>
    <updated>2014-02-26T00:53:15Z</updated>
    <summary type="html"><![CDATA[<div class="alert alert-danger">
<a href="/posts/2014/cabal-sandbox-zsh.html">zshでcabal-sandboxの状態を表示する</a>を見た方が良いかも知れません。
</div>
<h1 id="概要">概要</h1>
<p>cabal runの立ち上がりが遅いのでrunhaskellを使うrunsandboxを作った</p>
<!-- more -->

<h1 id="動機">動機</h1>
<p><code>cabal sandbox</code>使ってますか？私は使ってませんでした。</p>
<p>プロジェクト毎にコンパイルするの、特にyesodとかの巨大パッケージだと死ねます。まぁそれは最初の一回だけなので我慢しましょう。ぐっと我慢して使い始めてさあ実行してみよう、と<code>cabal run</code>すると……</p>
<pre class="sh"><code>$ time cabal run clean
Package has never been configured. Configuring with default flags. If this
fails, please run configure manually.
Resolving dependencies...
Configuring githubio-0.1.0.0...
Preprocessing executable 'githubio' for githubio-0.1.0.0...
[1 of 1] Compiling Main             ( site.hs, dist/build/githubio/githubio-tmp/Main.o )
Linking dist/build/githubio/githubio ...
Removing _site...
Removing _cache...
Removing _cache/tmp...
cabal run clean  10.36s user 1.25s system 92% cpu 12.613 total</code></pre>
<p>なんと言うことでしょう。10秒以上待たされました。なんといちいちコンパイルしているのです。 これでは私のようなちょっと書いて実行してみて考える、残念な人にとっては使い物になりません。</p>
<h1 id="解決法">解決法</h1>
<p>幸いにして<code>cabal.sandbox.config</code>のpackage-dbを食わせてやれば<code>runhaskell</code>でもsandbox中のパッケージを使えるようです。</p>
<pre class="sh"><code>$ grep package-db cabal.sanbox.config
package-db: `pwd`/.cabal-sandbox/x86_64-osx-ghc-7.6.3-packages.conf.d

$ time runhaskell -no-user-package-db -package-db=`pwd`/.cabal-sandbox/x86_64-osx-ghc-7.6.3-packages.conf.d site.hs clean
Removing _site...
Removing _cache...
Removing _cache/tmp...
runhaskell -no-user-package-db  site.hs clean  1.63s user 0.30s system 96% cpu 1.989 total</code></pre>
<p>ので、これを簡単に実行するプログラムを書きました。便利！</p>
<pre class="sh"><code>$ time runsandbox site.hs clean
Removing _site...
Removing _cache...
Removing _cache/tmp...
runsandbox site.hs clean  1.59s user 0.27s system 98% cpu 1.894 tota</code></pre>
<p>ソースは<a href="https://github.com/philopon/runsandbox">こちら</a></p>]]></summary>
</entry>
<entry>
    <title>Hakyllでgithub.ioにブログ作った</title>
    <link href="http://philopon.github.io/posts/2014/create_blog.html" />
    <id>http://philopon.github.io/posts/2014/create_blog.html</id>
    <published>2014-02-25T23:50:52Z</published>
    <updated>2014-02-25T23:50:52Z</updated>
    <summary type="html"><![CDATA[<p>テスト投稿を兼ねてこの記事を書いている時の操作について書いておきます。</p>
<ol style="list-style-type: decimal">
<li>Hakyllに<code>watch</code>引数を与えて起動する。</li>
<li>おもむろに記事を書く。<code>localhost:8000</code>でプレビューできる。</li>
<li>完成したら<a href="https://github.com/philopon/philopon.github.io/blob/sources/deploy.sh">デプロイスクリプト</a>を実行して記事&amp;元のmarkdownファイルをデプロイ。</li>
</ol>
<p>デプロイスクリプトでは、</p>
<ol style="list-style-type: decimal">
<li><code>site.hs rebuild</code>で再ビルド</li>
<li><code>_site</code>から<code>rsync</code>で<code>deploy</code>ディレクトリにコピー</li>
<li><code>deploy</code>ディレクトリ(remote originをphilopon.github.ioに、branchをmasterにしてる)に移動して全ファイルをgithub pagesのmasterブランチにpush</li>
<li>ルートディレクトリに戻って<code>posts</code>以下をsourcesブランチにpush</li>
</ol>
<p>みたいな操作をしております。<code>set -e</code>してるので3で新しいファイルが無かったりするとそこで止まってくれます。<code>set -e</code>便利。</p>]]></summary>
</entry>

</feed>
